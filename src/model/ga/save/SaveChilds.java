package model.ga.save;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;

import model.ga.internal.Indicators;
import system.rdf.dataBase.ConnectionToPostgres;
import system.rdf.dataBase.PersistentManager;
import system.rdf.dataBase.Problem;
import system.rdf.dataBase.RDFTriple;
import system.rename.Tools;
import model.ga.IGeneticAlgorithmStep;

public class SaveChilds implements IGeneticAlgorithmStep{

	//to draw generated problems
	private int subjectX;
	private int subjectY;

	private int objectX;
	private int objectY;

	//Point to start drawing generated problem
	private int initialX = 12;
	private int initialY = 18;
	private Tools tools = new  Tools();
	public Object getAssociatedData() {
		// TODO Auto-generated method stub
		return null;
	}

	public ArrayList<Problem> run(ArrayList<Problem> problems) throws SQLException {

		if(problems.size()== 0){
			System.out.println("Vac√≠o");
			return problems;	
		}
		Hashtable<String, Object> insertGraph = new Hashtable<String, Object>();
		Hashtable<String, Object> insertProblem = new Hashtable<String, Object>();
		Hashtable<String, Object> insertTriple = new Hashtable<String, Object>();
		Hashtable<String, Object> insertPoints = new Hashtable<String, Object>();

		ConnectionToPostgres connection = PersistentManager.getConnectionToPostgreSQL();

		ArrayList<Problem>problemArray = new ArrayList<Problem>();
		ArrayList<Indicators>tempArray = null;
		Problem problemToAdd;
		Tools tools =  new Tools();
		//number of problems that have already entered by the user
		for (int i = 0; i < problems.size(); i++) {

			//Generating relations for the currents problems
			insertGraph.put("description","Problem generated by AG");
			//Inserting a new Graph on DataBase
			connection.insert("graph", insertGraph);

			int idInsertedGraph = connection.getCurrentGraphId();

			insertProblem.put("name","Problem generated by AG" + new Date() + " " + i);
			insertProblem.put("id_graph", idInsertedGraph);

			//In memory Problem
			problemToAdd = new Problem();
			problemToAdd = problems.get(i);
			//Inserting a problem in database
			connection.insert("problem",insertProblem);

			for (int j = 0; j < problemToAdd.getTriples().size(); j++) {
				//In memory RDF triple
				RDFTriple tripleToAdd = new RDFTriple();

				//Validating the n-1 relations

				// Inserting triples
				insertTriple.put("id_graph", idInsertedGraph);
				//Here we get the subjects and objects frosm triples
				insertTriple.put("subject", problemToAdd.getTriples().get(j).getSubject().getLabel());
				insertTriple.put("predicate", "null");
				insertTriple.put("object", problemToAdd.getTriples().get(j).getObject().getLabel());
				insertTriple.put("subject_process",tools.concatenateProcess(problemToAdd.getTriples().get(j).getSubjetProcess()));
				insertTriple.put("object_process", tools.concatenateProcess(problemToAdd.getTriples().get(j).getObjectProcess()));

				// inserting the triples
				connection.insert("triple_rdf",insertTriple);

				int id = connection.getCurrentTripleId();
				insertPoints.put("id_triple", id);

				// the bounds of the rectangle are
				// x=12.0,y=18.0,w=163.0,h=49.0
				switch (j) {
				case 0:
					//Locating points for one triple, two indicators
					//x1,y1
					setSubjectX(initialX);
					setSubjectY(initialY);
					//x2,y1 x2 = x1 + size of rectangle(163) + 26
					setObjectX(initialX + 192);
					setObjectY(initialY);
					break;
				case 1:
					//Locating points for two triple, three indicators
					//Repeat the last triple
					setSubjectX(initialX + 192);
					setSubjectY(initialY);
					//x3,y1 x3 = x2 + 186 = x1 + 189 + 189
					setObjectX(initialX + 2*192);
					setObjectY(initialY);
					break;
				case 2:
					//Locating points for three triple, four indicators
					//Repeat the last triple x3,y1
					setSubjectX(initialX + 2*192);
					setSubjectY(initialY);
					//x1,y2 y2 = y1 + 49 + 30
					setObjectX(initialX);
					setObjectY(initialY + 78);
					break;
				case 3:
					//Locating points for four triple, five indicators
					//x1,y2 y2 = y1 + 49 + 30
					setSubjectX(initialX);
					setSubjectY(initialY + 78);
					//x2, y2
					setObjectX(initialX + 192);
					setObjectY(initialY + 78);
					break;
				case 4:
					//Locating points for five triple, six indicators
					setSubjectX(initialX + 192);
					setSubjectY(initialY + 78);
					//x3,y2
					setObjectX(initialX + 2*192);
					setObjectY(initialY + 78);
					break;
				case 5:
					//Locating points for six triple, seven indicators
					setSubjectX(initialX + 2*192);
					setSubjectY(initialY + 78);
					//x3,y2
					setObjectX(initialX);
					setObjectY(initialY + 49*2 + 29*2);
					break;
				case 6:
					//Locating points for seven triple, eight indicators
					setSubjectX(initialX);
					setSubjectY(initialY + 49*2 + 29*2);
					//x3,y2
					setObjectX(initialX + 192);
					setObjectY(initialY + 49*2 + 29*2);
					break;
				case 7:
					//Locating points for eight triple, nine indicators
					setSubjectX(initialX + 192);
					setSubjectY(initialY + 49*2 + 29*2);
					//x3,y2
					setObjectX(initialX + 192*2);
					setObjectY(initialY + 49*2 + 29*2);
					break;
				}

				// inserting the cell's points, this is necessary to Check it later
				insertPoints.put("subject_x",this.getSubjectX());
				insertPoints.put("subject_y",this.getSubjectY());

				insertPoints.put("object_x",this.getObjectX());
				insertPoints.put("object_y",this.getObjectY());

				connection.insert("vertex_points",insertPoints);
			}

		}

		return problems;
	}

	/**
	 * @param initialX the initialX to set
	 */
	protected void setInitialX(int initialX) {
		this.initialX = initialX;
	}
	/**
	 * @param initialY the initialY to set
	 */
	protected void setInitialY(int initialY) {
		this.initialY = initialY;
	}
	/**
	 * @return the subjectX
	 */
	protected int getSubjectX() {
		return subjectX;
	}
	/**
	 * @param subjectX the subjectX to set
	 */
	protected void setSubjectX(int subjectX) {
		this.subjectX = subjectX;
	}
	/**
	 * @return the subjectY
	 */
	protected int getSubjectY() {
		return subjectY;
	}
	/**
	 * @param subjectY the subjectY to set
	 */
	protected void setSubjectY(int subjectY) {
		this.subjectY = subjectY;
	}
	/**
	 * @return the objectX
	 */
	protected int getObjectX() {
		return objectX;
	}
	/**
	 * @param objectX the objectX to set
	 */
	protected void setObjectX(int objectX) {
		this.objectX = objectX;
	}
	/**
	 * @return the objectY
	 */
	protected int getObjectY() {
		return objectY;
	}
	/**
	 * @param objectY the objectY to set
	 */
	protected void setObjectY(int objectY) {
		this.objectY = objectY;


	}

}
